# Phase 3: Runtime Service Update - Summary

## Overview

This document summarizes the updates made to the runtime service to support API mode for SSH execution with runtime helpers.

## Completed Updates

### 1. JWT Token Compatibility

- Updated `Claims` struct in runtime service to include `JobID` field from orchestrator tokens
- Modified `TokenClaims` type to include `JobID` for complete token information
- Runtime service now accepts and validates JWT tokens generated by the orchestrator

### 2. Existing Runtime Service Features

The runtime service was already well-architected with:

#### API Endpoints

- `GET /executions/{id}/input` - Get input data for execution
- `POST /executions/{id}/output` - Set output data from execution
- `GET /executions/{id}/context` - Get execution context
- `GET /executions/{id}/variables/{key}` - Get variable value
- `PUT /executions/{id}/variables/{key}` - Set variable value
- `POST /executions/{id}/condition` - Set workflow condition result
- `POST /tool-actions/execute` - Execute tool actions

#### Middleware

- JWT authentication middleware that validates tokens
- Rate limiting middleware
- Request logging middleware
- CORS support

#### Backend Integration

- Backend client for fetching execution context from main API
- Support for variable management with user isolation
- Audit logging for all operations
- Tool action execution proxy

#### Caching Layer

- Valkey (Redis) integration for caching
- Caches execution context, variables, input/output data
- Distributed locking for concurrent variable updates

## How It Works

### API Mode Flow

1. **Orchestrator Side**:
   - Generates JWT token with job execution details
   - Establishes SSH reverse tunnel (remote:9090 -> local:8089)
   - Passes configuration via environment variables:
     - `CRONIUM_HELPER_MODE=api`
     - `CRONIUM_API_ENDPOINT=http://127.0.0.1:9090`
     - `CRONIUM_API_TOKEN=<jwt-token>`
     - `CRONIUM_EXECUTION_ID=<execution-id>`

2. **Runner Side**:
   - Detects API mode from environment variables
   - Environment variables take precedence over manifest
   - Configures helpers to use API mode

3. **Runtime Helpers**:
   - Make HTTP requests to runtime API via tunnel
   - Include JWT token in Authorization header
   - API validates token and execution ID match

4. **Runtime Service**:
   - Validates JWT tokens from orchestrator
   - Fetches execution context from backend (or cache)
   - Handles helper API requests
   - Stores data in cache and backend

## Testing

### Test Scripts Created

1. **`test/test-ssh-api-mode.sh`** - Full integration test setup
2. **`test/mock-runtime-api.go`** - Mock runtime API for testing
3. **`apps/runner/cronium-runner/test/test-helpers-env.sh`** - Test helpers with env vars
4. **`apps/runner/cronium-runner/test/test-api-mode.sh`** - Basic API mode test

### Running Tests

1. **Start Mock Runtime API**:

   ```bash
   cd test && go run mock-runtime-api.go
   ```

2. **Test Helpers Directly**:

   ```bash
   ./apps/runner/cronium-runner/test/test-helpers-env.sh
   # Follow the instructions printed
   ```

3. **Full SSH Test**:
   ```bash
   ./test/test-ssh-api-mode.sh
   # Use the generated payload with orchestrator
   ```

## Configuration Requirements

### Orchestrator

- Set runtime port (default: 8089)
- Configure JWT secret (must match runtime service)
- Enable API mode in SSH executor

### Runtime Service

- Configure JWT secret (must match orchestrator)
- Set backend API URL and token
- Configure Valkey/Redis connection

### Example Configuration

```yaml
# Orchestrator config
container:
  runtime:
    jwtSecret: "your-secret-key"

# Runtime service config
auth:
  jwtSecret: "your-secret-key"
backend:
  url: "http://localhost:3000"
  token: "backend-api-token"
```

## Next Steps

1. **Integration Testing**: Test the complete flow with real SSH connections
2. **Performance Optimization**:
   - Connection pooling for runtime API
   - Optimize tunnel port allocation
   - Add request batching for helpers
3. **Monitoring**: Add metrics for API mode usage and performance
4. **Documentation**: Create user guide for API mode configuration

## Benefits of API Mode

1. **Real-time Data Access**: Scripts can access live data from the platform
2. **Shared State**: Multiple scripts can share variables and data
3. **Tool Integration**: Direct access to platform tools (Slack, Email, etc.)
4. **Audit Trail**: All operations are logged and tracked
5. **Security**: JWT-based authentication and execution isolation
