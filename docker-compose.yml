services:
  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: cronium-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-cronium}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-cronium}
      POSTGRES_DB: ${POSTGRES_DB:-cronium}
      POSTGRES_MAX_CONNECTIONS: ${POSTGRES_MAX_CONNECTIONS:-100}
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-cronium}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - cronium-network

  # Valkey (Redis-compatible) for caching and queue
  valkey:
    image: valkey/valkey:7-alpine
    container_name: cronium-valkey
    command: valkey-server --appendonly yes --maxmemory ${VALKEY_MAX_MEMORY:-256mb} --maxmemory-policy allkeys-lru
    ports:
      - "${VALKEY_PORT:-6379}:6379"
    volumes:
      - valkey_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "valkey-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - cronium-network

  # Orchestrator Service (cronium-agent)
  cronium-agent:
    build:
      context: ./orchestrator/cronium-orchestrator
      dockerfile: Dockerfile
      args:
        BUILD_VERSION: ${BUILD_VERSION:-latest}
    image: cronium/orchestrator:${BUILD_VERSION:-latest}
    container_name: cronium-agent
    environment:
      # Configuration file path
      CONFIG_FILE: /app/config/cronium-orchestrator.yaml

      # API Configuration (CRONIUM_ prefix required)
      CRONIUM_API_ENDPOINT: http://cronium-app:5001
      CRONIUM_API_TOKEN: ${INTERNAL_API_KEY}

      # Server Configuration
      CRONIUM_SERVER_ID: ${ORCHESTRATOR_ID:-prod-orchestrator-01}
      CRONIUM_SERVER_PORT: 8080
      CRONIUM_SERVER_METRICS_ENABLED: true
      CRONIUM_SERVER_METRICS_PORT: 9090

      # Jobs Configuration
      CRONIUM_JOBS_MAX_CONCURRENT: ${MAX_CONCURRENT_JOBS:-10}
      CRONIUM_JOBS_POLL_INTERVAL: ${JOB_POLL_INTERVAL:-5s}
      CRONIUM_JOBS_HEARTBEAT_INTERVAL: 30s
      CRONIUM_JOBS_TIMEOUT: 24h

      # Container Configuration
      CRONIUM_CONTAINER_DOCKER_ENDPOINT: unix:///var/run/docker.sock
      CRONIUM_CONTAINER_RUNTIME_IMAGE: cronium/runtime-api:latest
      CRONIUM_CONTAINER_RUNTIME_JWT_SECRET: ${JWT_SECRET}
      CRONIUM_CONTAINER_RUNTIME_BACKEND_URL: http://cronium-app:5001
      CRONIUM_CONTAINER_RUNTIME_VALKEY_URL: valkey://valkey:6379

      # Logging
      CRONIUM_LOGGING_LEVEL: ${LOG_LEVEL:-info}
      CRONIUM_LOGGING_FORMAT: json

      # Direct environment variables (no prefix)
      DOCKER_HOST: unix:///var/run/docker.sock
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./orchestrator/cronium-orchestrator/configs:/app/config:ro
      - orchestrator_data:/app/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - cronium-network
    security_opt:
      - no-new-privileges:true

  # Main Cronium Application
  cronium-app:
    build:
      context: .
      dockerfile: Dockerfile
      target: runner
      args:
        BUILD_VERSION: ${BUILD_VERSION:-latest}
    image: cronium/app:${BUILD_VERSION:-latest}
    container_name: cronium-app
    ports:
      - "${APP_PORT:-5001}:5001"
      - "${SOCKET_PORT:-5002}:5002"
    environment:
      # Database
      DATABASE_URL: postgresql://${POSTGRES_USER:-cronium}:${POSTGRES_PASSWORD:-cronium}@postgres:5432/${POSTGRES_DB:-cronium}?sslmode=${DB_SSL_MODE:-disable}

      # Auth
      AUTH_URL: ${AUTH_URL:-http://localhost:5001}
      AUTH_SECRET: ${AUTH_SECRET}

      # Encryption
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}

      # Services
      ORCHESTRATOR_URL: http://cronium-agent:8080
      INTERNAL_API_KEY: ${INTERNAL_API_KEY}
      JWT_SECRET: ${JWT_SECRET}

      # WebSocket
      SOCKET_PORT: 5002
      NEXT_PUBLIC_SOCKET_PORT: ${SOCKET_PORT:-5002}
      NEXT_PUBLIC_SOCKET_URL: ${SOCKET_URL:-http://localhost:5002}

      # Valkey
      VALKEY_URL: valkey://valkey:6379

      # App Configuration
      NODE_ENV: ${NODE_ENV:-production}
      LOG_LEVEL: ${LOG_LEVEL:-info}

      # Email (optional)
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}

      # AI (optional)
      OPENAI_API_KEY: ${OPENAI_API_KEY}

      # External monitoring (optional)
      PROMETHEUS_URL: ${PROMETHEUS_URL}
      GRAFANA_URL: ${GRAFANA_URL}
    command: sh -c "node server.js & node .next/standalone/server.js"
    depends_on:
      postgres:
        condition: service_healthy
      valkey:
        condition: service_healthy
      cronium-agent:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test:
        ["CMD", "wget", "-q", "--spider", "http://localhost:5001/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - cronium-network

volumes:
  postgres_data:
    driver: local
  valkey_data:
    driver: local
  orchestrator_data:
    driver: local

networks:
  cronium-network:
    driver: bridge
